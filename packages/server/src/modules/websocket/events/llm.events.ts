import { Injectable, Logger } from '@nestjs/common';
import { WebSocketGatewayService } from '../websocket.gateway';
import { LLMService, ChatMessage } from '../../llm/llm.service';

/**
 * LLM Events Handler
 * 
 * Handles streaming of LLM responses over WebSocket.
 * Emits token chunks as they are generated by the LLM provider.
 */
@Injectable()
export class LLMEventsHandler {
  private readonly logger = new Logger(LLMEventsHandler.name);
  
  // Track active streaming sessions
  private activeStreams = new Map<string, { cancelled: boolean }>();

  constructor(
    private readonly llmService: LLMService,
  ) {}

  /**
   * Set WebSocket gateway after it's initialized
   * This avoids circular dependency issues
   */
  private wsGateway: WebSocketGatewayService;
  
  setWebSocketGateway(gateway: WebSocketGatewayService) {
    this.wsGateway = gateway;
  }

  /**
   * Stream LLM chat response to a specific client
   * 
   * @param clientId - Socket client ID
   * @param sessionId - Unique session ID for this stream
   * @param provider - LLM provider name
   * @param messages - Chat message history
   */
  async streamChatResponse(
    clientId: string,
    sessionId: string,
    provider: string,
    messages: ChatMessage[],
  ): Promise<void> {
    if (!this.wsGateway) {
      throw new Error('WebSocket gateway not initialized');
    }

    // Track this stream
    this.activeStreams.set(sessionId, { cancelled: false });

    try {
      this.logger.debug(
        `Starting LLM stream - Session: ${sessionId}, Provider: ${provider}, Client: ${clientId}`,
      );

      // Emit stream start event
      this.wsGateway.sendToClient(clientId, 'llm:stream:start', {
        sessionId,
        provider,
        timestamp: new Date().toISOString(),
      });

      let fullResponse = '';
      let tokenCount = 0;

      // Stream tokens from LLM provider
      for await (const token of this.llmService.streamChat(provider, messages)) {
        // Check if stream was cancelled
        const streamState = this.activeStreams.get(sessionId);
        if (!streamState || streamState.cancelled) {
          this.logger.log(`Stream cancelled - Session: ${sessionId}`);
          this.wsGateway.sendToClient(clientId, 'llm:stream:cancelled', {
            sessionId,
            timestamp: new Date().toISOString(),
          });
          break;
        }

        fullResponse += token;
        tokenCount++;

        // Emit token to client
        this.wsGateway.sendToClient(clientId, 'llm:stream:token', {
          sessionId,
          token,
          timestamp: new Date().toISOString(),
        });
      }

      // Only emit done if not cancelled
      const streamState = this.activeStreams.get(sessionId);
      if (streamState && !streamState.cancelled) {
        // Emit stream complete event
        this.wsGateway.sendToClient(clientId, 'llm:stream:done', {
          sessionId,
          provider,
          fullResponse,
          tokenCount,
          timestamp: new Date().toISOString(),
        });

        this.logger.debug(
          `LLM stream completed - Session: ${sessionId}, Tokens: ${tokenCount}`,
        );
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(
        `LLM stream error - Session: ${sessionId}, Error: ${errorMessage}`,
      );

      // Emit error event to client
      this.wsGateway.sendToClient(clientId, 'llm:stream:error', {
        sessionId,
        error: errorMessage,
        timestamp: new Date().toISOString(),
      });
    } finally {
      // Clean up stream tracking
      this.activeStreams.delete(sessionId);
    }
  }

  /**
   * Cancel an active streaming session
   * 
   * @param sessionId - Unique session ID to cancel
   */
  cancelStream(sessionId: string): boolean {
    const streamState = this.activeStreams.get(sessionId);
    if (streamState) {
      streamState.cancelled = true;
      this.logger.log(`Stream cancellation requested - Session: ${sessionId}`);
      return true;
    }
    return false;
  }

  /**
   * Get count of active streaming sessions
   */
  getActiveStreamCount(): number {
    return this.activeStreams.size;
  }

  /**
   * Clean up all active streams (for graceful shutdown)
   */
  cancelAllStreams(): void {
    this.logger.log(
      `Cancelling all active streams - Count: ${this.activeStreams.size}`,
    );
    
    for (const [sessionId, streamState] of this.activeStreams.entries()) {
      streamState.cancelled = true;
    }
  }
}
